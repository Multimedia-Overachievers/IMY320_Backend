{
    "name": "COS 333",
    "chapters": [
        {
            "id": 0,
            "name": "Chapter 1 - Preliminaries",
            "questions": [
                {
                    "id": 0,
                    "question": "Which one of the following is a reason to study the concepts of programming languages?",
                    "answers": [
                        {
                            "answer": "Overall advancement of computing",
                            "correct": true
                        },
                        {
                            "answer": "Decreased ability to express ideas",
                            "correct": false
                        },
                        {
                            "answer": "Decreased ability to learn new languages",
                            "correct": false
                        },
                        {
                            "answer": "Worse understanding of significance of implementation",
                            "correct": false
                        }
                    ],
                    "explanation" : "Understanding programming languages contributes to the overall advancement of computing by enabling the development of more efficient and innovative software.",
                    "finished": false
                },
                {
                    "id": 1,
                    "question": "If a structure is not supported in a language you can still simulate them.",
                    "answers": [
                        {
                            "answer": "True",
                            "correct": true
                        },
                        {
                            "answer": "False",
                            "correct": false
                        }
                    ],
                    "explanation" : "In a programming language, if a certain data structure or feature is not natively supported, you can still create simulations or workarounds to achieve the desired functionality.",
                    "finished": false
                },
                {
                    "id": 2,
                    "question": "It’s better to choose a language where a major feature is supported rather than use another language where you have to simulate it",
                    "answers": [
                        {
                            "answer": "True",
                            "correct": true
                        },
                        {
                            "answer": "False",
                            "correct": false
                        }
                    ],
                    "explanation" : "It's preferable to select a programming language that natively supports a major feature rather than using another language where you have to simulate it, as it usually results in more efficient and maintainable code.",
                    "finished": false
                },
                {
                    "id": 3,
                    "question": "Pick the most correct option.",
                    "answers": [
                        {
                            "answer": "C++ is very readable",
                            "correct": false
                        },
                        {
                            "answer": "C++ is very writable",
                            "correct": true
                        },
                        {
                            "answer": "C++ is very reliable",
                            "correct": false
                        },
                        {
                            "answer": "C++ is very costly",
                            "correct": false
                        }
                    ],
                    "explanation" : "C++ provides extensive capabilities for writing code, making it a powerful language for developing software.",
                    "finished": false
                },
                {
                    "id": 4,
                    "question": "PL/1 is more orthogonal than ALGOL 68.",
                    "answers": [
                        {
                            "answer": "True",
                            "correct": false
                        },
                        {
                            "answer": "False",
                            "correct": true
                        }
                    ],
                    "explanation" : "This statement is false because ALGOL 68 is considered more orthogonal than PL/1 because more constructs can be combined in ALGOL 68 with minimal exceptions.",
                    "finished": false
                },
                {
                    "id": 5,
                    "question": "Cost refers to how much money is spent:",
                    "answers": [
                        {
                            "answer": "Buying hardware",
                            "correct": false
                        },
                        {
                            "answer": "Buying software",
                            "correct": false
                        },
                        {
                            "answer": "Training programmers",
                            "correct": true
                        },
                        {
                            "answer": "Selling software",
                            "correct": false
                        }
                    ],
                    "explanation" : "It costs money to train developers in-house.",
                    "finished": false
                },
                {
                    "id": 6,
                    "question": "What region was Prolog mostly used in?",
                    "answers": [
                        {
                            "answer": "Business applications",
                            "correct": false
                        },
                        {
                            "answer": "Systems Programming",
                            "correct": false
                        },
                        {
                            "answer": "Scientific applications",
                            "correct": false
                        },
                        {
                            "answer": "Artificial Intelligence",
                            "correct": true
                        }
                    ],
                    "explanation" : "Prolog gained prominence as a programming language primarily used in the field of Artificial Intelligence due to its logical reasoning capabilities.",
                    "finished": false
                },
                {
                    "id": 7,
                    "question": "Imperative languages are based on the von Neumann architecture because.",
                    "answers": [
                        {
                            "answer": "Only data is stored in memory",
                            "correct": false
                        },
                        {
                            "answer": "Memory is not separate from the CPU",
                            "correct": false
                        },
                        {
                            "answer": "Instructions and data are piped from memory to CPU",
                            "correct": true
                        },
                        {
                            "answer": "Variables model pointers",
                            "correct": false
                        }
                    ],
                    "explanation" : "Imperative languages are designed to work with von Neumann architecture, where instructions and data share the same memory and are fetched from memory to the CPU.",
                    "finished": false
                },
                {
                    "id": 8,
                    "question": "Object-oriented programming took off the middle of the 1980s.",
                    "answers": [
                        {
                            "answer": "True",
                            "correct": true
                        },
                        {
                            "answer": "False",
                            "correct": false
                        }
                    ],
                    "explanation" : "Object-oriented programming gained widespread adoption in the mid-1980s, with languages like C++ and Smalltalk contributing to its popularity.",
                    "finished": false
                },
                {
                    "id": 9,
                    "question": "Which one of the following is not a functional programming language?",
                    "answers": [
                        {
                            "answer": "LISP",
                            "correct": false
                        },
                        {
                            "answer": "Scheme",
                            "correct": false
                        },
                        {
                            "answer": "ML",
                            "correct": false
                        },
                        {
                            "answer": "Perl",
                            "correct": true
                        }
                    ],
                    "explanation" : "Perl is primarily an imperative and scripting language, not a functional programming language.",
                    "finished": false
                },
                {
                    "id": 10,
                    "question": "Pick the most correct option.",
                    "answers": [
                        {
                            "answer": "In compilation, programs are translated into machine language",
                            "correct": true
                        },
                        {
                            "answer": "In pure interpretation, programs are translated into machine language",
                            "correct": false
                        },
                        {
                            "answer": "In compilation, programs are interpreted by another program",
                            "correct": false
                        },
                        {
                            "answer": "In pure interpretation, a compromise is made between compilation and pure interpretation",
                            "correct": false
                        }
                    ],
                    "explanation" : "In compilation, programs are translated into machine code before execution, whereas pure interpretation executes code directly without prior translation.",
                    "finished": false
                },
                {
                    "id": 11,
                    "question": "Which one of the following is not part of the compilation process?",
                    "answers": [
                        {
                            "answer": "Lexical analysis",
                            "correct": false
                        },
                        {
                            "answer": "Syntax analysis",
                            "correct": false
                        },
                        {
                            "answer": "Parse analysis",
                            "correct": true
                        },
                        {
                            "answer": "Code generation",
                            "correct": false
                        }
                    ],
                    "explanation" : "Parse analysis is not a part of the compilation process; it's typically part of syntax analysis.",
                    "finished": false
                },
                {
                    "id": 12,
                    "question": "Pure interpretation is faster than compilation.",
                    "answers": [
                        {
                            "answer": "True",
                            "correct": false
                        },
                        {
                            "answer": "False",
                            "correct": true
                        }
                    ],
                    "explanation" : "Compilation often results in faster execution because the code is translated into a more optimized form, while pure interpretation executes code line-by-line.",
                    "finished": false
                },
                {
                    "id": 13,
                    "question": "Pure interpretation is used by scripting languages because:",
                    "answers": [
                        {
                            "answer": "Different browsers have to run on different operating systems",
                            "correct": true
                        },
                        {
                            "answer": "The languages have to work directly on the computer",
                            "correct": false
                        },
                        {
                            "answer": "It’s faster to run these languages on the browser",
                            "correct": false
                        },
                        {
                            "answer": "It’s slow to run on a computer",
                            "correct": false
                        }
                    ],
                    "explanation" : "Scripting languages often use pure interpretation because they need to work across different browsers and operating systems without the need for compilation.",
                    "finished": false
                },
                {
                    "id": 14,
                    "question": "Java implementations use a compilation system",
                    "answers": [
                        {
                            "answer": "True",
                            "correct": false
                        },
                        {
                            "answer": "False",
                            "correct": true
                        }
                    ],
                    "explanation" : "Java typically uses a combination of compilation and interpretation, with the Java source code compiled into bytecode and then interpreted by the Java Virtual Machine (JVM).",
                    "finished": false
                }
            ]
        },
        {
            "id": 1,
            "name": "Chapter 2 - Evolution of the Major Programming Languages",
            "questions": [
                {
                    "id": 0,
                    "question": "Pick the most correct option.",
                    "answers": [
                        {
                            "answer": "Expression coding had poor readability",
                            "correct": true
                        },
                        {
                            "answer": "Expression coding had good writability",
                            "correct": false
                        },
                        {
                            "answer": "Expression coding had good modifiability",
                            "correct": false
                        },
                        {
                            "answer": "Expression coding had good reliability",
                            "correct": false
                        }
                    ],
                    "explanation" : "Expression coding typically sacrifices readability, prioritizing concise code over easily understandable code.",
                    "finished": false
                },
                {
                    "id": 1,
                    "question": "Plankalkul was the first programming language to introduce invariants.",
                    "answers": [
                        {
                            "answer": "True",
                            "correct": true
                        },
                        {
                            "answer": "False",
                            "correct": false
                        }
                    ],
                    "explanation" : "Plankalkul, developed by Konrad Zuse, introduced the concept of invariants in programming languages, which are conditions that must always hold true during program execution.",
                    "finished": false
                },
                {
                    "id": 2,
                    "question": "The UNIVAC compiling systems were the first introduction to compilation because:",
                    "answers": [
                        {
                            "answer": "Programs were starting to get larger",
                            "correct": false
                        },
                        {
                            "answer": "Programs were starting to get smaller",
                            "correct": false
                        },
                        {
                            "answer": "Machine hardware wasn’t improving at the same pace programming languages were",
                            "correct": true
                        },
                        {
                            "answer": "Machine hardware was outpacing programming languages",
                            "correct": false
                        }
                    ],
                    "explanation" : "The UNIVAC compiling systems played a crucial role in the early development of compilation because they were needed to improve the efficiency of programming on machines whose hardware capabilities were not advancing as rapidly as programming languages were evolving.",
                    "finished": false
                },
                {
                    "id": 3,
                    "question": "Fortran 0 was a language that was implemented",
                    "answers": [
                        {
                            "answer": "True",
                            "correct": false
                        },
                        {
                            "answer": "False",
                            "correct": true
                        }
                    ],
                    "explanation" : "Fortran 0 was never implemented as a programming language; it was a conceptual precursor to the Fortran programming language.",
                    "finished": false
                },
                {
                    "id": 4,
                    "question": "Fortan was based on the Object-oriented paradigm.",
                    "answers": [
                        {
                            "answer": "True",
                            "correct": false
                        },
                        {
                            "answer": "False",
                            "correct": true
                        }
                    ],
                    "explanation" : "Fortran is not based on the Object-oriented paradigm. It is primarily an imperative and procedural programming language.",
                    "finished": false
                },
                {
                    "id": 5,
                    "question": "ALGOL 60 was a universal language because:",
                    "answers": [
                        {
                            "answer": "It strived for machine independence",
                            "correct": true
                        },
                        {
                            "answer": "It could be used for any domain",
                            "correct": false
                        },
                        {
                            "answer": "It could be used by anyone from any background",
                            "correct": false
                        },
                        {
                            "answer": "It could be easily converted to other languages",
                            "correct": false
                        }
                    ],
                    "explanation" : "ALGOL 60 aimed to be a universal programming language that could be used on various machines, and one of its goals was to achieve machine independence.",
                    "finished": false
                },
                {
                    "id": 6,
                    "question": "PL/I is not an orthogonal language.",
                    "answers": [
                        {
                            "answer": "True",
                            "correct": false
                        },
                        {
                            "answer": "False",
                            "correct": true
                        }
                    ],
                    "explanation" : "PL/I is considered not to be fully orthogonal because it introduced some irregularities in language design, making it less consistent in its use of language features.",
                    "finished": false
                },
                {
                    "id": 7,
                    "question": "The goal of ALGOL 60 was to be:",
                    "answers": [
                        {
                            "answer": "As close to machine language as possible",
                            "correct": false
                        },
                        {
                            "answer": "Good for describing algorithms",
                            "correct": true
                        },
                        {
                            "answer": "Closely mimic the hardware it runs on",
                            "correct": false
                        },
                        {
                            "answer": "Based on the functional paradigm",
                            "correct": false
                        }
                    ],
                    "explanation" : "ALGOL 60 was designed with a primary goal of providing a language that could express algorithms in a clear and precise manner.",
                    "finished": false
                },
                {
                    "id": 8,
                    "question": "C++ has good reliability.",
                    "answers": [
                        {
                            "answer": "True",
                            "correct": false
                        },
                        {
                            "answer": "False",
                            "correct": true
                        }
                    ],
                    "explanation" : "C++ is known for its performance and control but not necessarily for high-level reliability features. The reliability of C code depends on the skill of the programmer.",
                    "finished": false
                },
                {
                    "id": 9,
                    "question": "Which of the following was not included in ALGOL 58?",
                    "answers": [
                        {
                            "answer": "Names can only be 12 character long",
                            "correct": true
                        },
                        {
                            "answer": "Arrays can have any number of subscripts",
                            "correct": false
                        },
                        {
                            "answer": "Parameters were separated by mode",
                            "correct": false
                        },
                        {
                            "answer": "Semicolons were used as a statement separator",
                            "correct": false
                        }
                    ],
                    "explanation" : "ALGOL 58 did not have a limitation where variable names could only be 12 characters long, names could consist of any number of characters.",
                    "finished": false
                },
                {
                    "id": 10,
                    "question": "Smalltalk was the first pure object-oriented language.",
                    "answers": [
                        {
                            "answer": "True",
                            "correct": false
                        },
                        {
                            "answer": "False",
                            "correct": true
                        }
                    ],
                    "explanation" : "Smalltalk is often credited as the first pure object-oriented programming language.",
                    "finished": false
                },
                {
                    "id": 11,
                    "question": "ALGOL 60 had no I/O or string handling because:",
                    "answers": [
                        {
                            "answer": "It was too expensive to implement it",
                            "correct": false
                        },
                        {
                            "answer": "There was no time to implement it",
                            "correct": false
                        },
                        {
                            "answer": "It would make the language machine dependent",
                            "correct": true
                        },
                        {
                            "answer": "They didn’t know how to implement it",
                            "correct": false
                        }
                    ],
                    "explanation" : "ALGOL 60 intentionally omitted I/O and string handling to ensure machine independence and avoid tying the language to specific hardware or input/output systems.",
                    "finished": false
                },
                {
                    "id": 12,
                    "question": "Java is a more powerful and flexible version of C++.",
                    "answers": [
                        {
                            "answer": "True",
                            "correct": false
                        },
                        {
                            "answer": "False",
                            "correct": true
                        }
                    ],
                    "explanation" : "C++ is more powerful and flexible than Java because C++ gives the programmer more control over lower level constructs.",
                    "finished": false
                },
                {
                    "id": 13,
                    "question": "ALGOL 60 was a failure because:",
                    "answers": [
                        {
                            "answer": "It wasn’t flexible enough",
                            "correct": false
                        },
                        {
                            "answer": "There was too much support from IBM",
                            "correct": false
                        },
                        {
                            "answer": "The formal syntax was too simple",
                            "correct": false
                        },
                        {
                            "answer": "Of the lack of I/O",
                            "correct": true
                        }
                    ],
                    "explanation" : "One of the reasons for ALGOL 60's limited success was its lack of standardized I/O facilities, which made it less practical for real-world programming",
                    "finished": false
                },
                {
                    "id": 14,
                    "question": "Ruby was the first German language to be widely used in the USA.",
                    "answers": [
                        {
                            "answer": "True",
                            "correct": false
                        },
                        {
                            "answer": "False",
                            "correct": true
                        }
                    ],
                    "explanation" : "Ruby is a programming language, not a spoken language. It originated in Japan and gained popularity worldwide as a programming language, including in the USA.",
                    "finished": false
                }
            ]
        },
        {
            "id": 2,
            "name": "Chapter 3 - Functional Programming Languages",
            "questions": [
                {
                    "id": 0,
                    "question": "Functional programming languages closely mimic mathematical functions",
                    "answers": [
                        {
                            "answer": "True",
                            "correct": true
                        },
                        {
                            "answer": "False",
                            "correct": false
                        }
                    ],
                    "explanation" : "Functional programming languages are designed to model computations as mathematical functions, emphasizing immutability and the absence of functional side effects.",
                    "finished": false
                },
                {
                    "id": 1,
                    "question": "",
                    "answers": [
                        {
                            "answer": "True",
                            "correct": false
                        },
                        {
                            "answer": "False",
                            "correct": true
                        }
                    ],
                    "explanation" : "Functional programming languages, in contrast to imperative languages, are not based on the von Neumann architecture, as they emphasize the evaluation of mathematical functions and avoid mutable state.",
                    "finished": false
                },
                {
                    "id": 2,
                    "question": "Which one of the following is a breakdown in referential transparency.",
                    "answers": [
                        {
                            "answer": "Pure functions",
                            "correct": false
                        },
                        {
                            "answer": "Lazy Evaluation",
                            "correct": false
                        },
                        {
                            "answer": "Immutable Data Structures",
                            "correct": false
                        },
                        {
                            "answer": "Mutable State",
                            "correct": true
                        }
                    ],
                    "explanation" : "Referential transparency is compromised when mutable state is present because the same function call may yield different results depending on the state of mutable variables.",
                    "finished": false
                },
                {
                    "id": 3,
                    "question": "Functions are first-class entities because:",
                    "answers": [
                        {
                            "answer": "Expressions can evaluate to functions",
                            "correct": true
                        },
                        {
                            "answer": "Functions cannot be elements in lists",
                            "correct": false
                        },
                        {
                            "answer": "Functions cannot be passed as function parameters",
                            "correct": false
                        },
                        {
                            "answer": "Functions cannot be returned from functions",
                            "correct": false
                        }
                    ],
                    "explanation" : "In functional programming, functions are considered first-class citizens, meaning they can be treated as values, passed as arguments to other functions, returned from functions, and assigned to variables.",
                    "finished": false
                },
                {
                    "id": 4,
                    "question": "The Scheme interpreter operates in a REPL mode",
                    "answers": [
                        {
                            "answer": "True",
                            "correct": true
                        },
                        {
                            "answer": "False",
                            "correct": false
                        }
                    ],
                    "explanation" : "The Scheme interpreter typically operates in a Read-Eval-Print Loop (REPL) mode, allowing users to interactively input and evaluate Scheme expressions.",
                    "finished": false
                },
                {
                    "id": 5,
                    "question": "For the COND control flow, if no predicate is true:",
                    "answers": [
                        {
                            "answer": "It evaluates to the optional else expression",
                            "correct": true
                        },
                        {
                            "answer": "It evaluates to the first predicate expression",
                            "correct": false
                        },
                        {
                            "answer": "It evaluates to the second predicate expression",
                            "correct": false
                        },
                        {
                            "answer": "It evaluates to the third predicate expression",
                            "correct": false
                        }
                    ],
                    "explanation" : "In Scheme's COND construct, if none of the predicate expressions evaluates to true, the COND evaluates to the optional else expression.",
                    "finished": false
                },
                {
                    "id": 6,
                    "question": "Which of the following is not a predefine predicate function?",
                    "answers": [
                        {
                            "answer": "EVEN?",
                            "correct": false
                        },
                        {
                            "answer": "ODD?",
                            "correct": false
                        },
                        {
                            "answer": "ZERO?",
                            "correct": false
                        },
                        {
                            "answer": "POSITIVE?",
                            "correct": true
                        }
                    ],
                    "explanation" : "In Scheme, POSITIVE? is not a predefined predicate function. Predefined predicates typically include functions like 'EVEN?', 'ODD?', and ZERO?.",
                    "finished": false
                },
                {
                    "id": 7,
                    "question": "All repetition is handled through control loop structures.",
                    "answers": [
                        {
                            "answer": "True",
                            "correct": false
                        },
                        {
                            "answer": "False",
                            "correct": true
                        }
                    ],
                    "explanation" : "In functional programming, repetition can be achieved through recursion and higher-order functions, not exclusively through control loop structures.",
                    "finished": false
                },
                {
                    "id": 8,
                    "question": "Scheme uses variables.",
                    "answers": [
                        {
                            "answer": "True",
                            "correct": false
                        },
                        {
                            "answer": "False",
                            "correct": true
                        }
                    ],
                    "explanation" : "Scheme uses variables to bind values, but it employs lexical scoping and encourages immutability, making variables behave differently than in imperative languages.",
                    "finished": false
                },
                {
                    "id": 9,
                    "question": "(CONS ‘A ‘(B C)) will yield:",
                    "answers": [
                        {
                            "answer": "((A B) C D)",
                            "correct": false
                        },
                        {
                            "answer": "(A . B)",
                            "correct": false
                        },
                        {
                            "answer": "(() A B)",
                            "correct": false
                        },
                        {
                            "answer": "(A B C)",
                            "correct": true
                        }
                    ],
                    "explanation" : "The CONS function in Scheme creates a new list by adding the first element ('A) to the front of the second list ('(B C)), resulting in (A B C).",
                    "finished": false
                },
                {
                    "id": 10,
                    "question": "The equal function can only be applied to:",
                    "answers": [
                        {
                            "answer": "One list",
                            "correct": false
                        },
                        {
                            "answer": "Two lists",
                            "correct": true
                        },
                        {
                            "answer": "Three lists",
                            "correct": false
                        },
                        {
                            "answer": "Four lists",
                            "correct": false
                        }
                    ],
                    "explanation" : "In Scheme, the EQUAL function is typically used to compare two lists or other data structures for structural equality.",
                    "finished": false
                },
                {
                    "id": 11,
                    "question": "Pick the most correct option:",
                    "answers": [
                        {
                            "answer": "Recursive functions are faster than iterative constructs",
                            "correct": false
                        },
                        {
                            "answer": "Recursive functions are slower than iterative constructs",
                            "correct": true
                        },
                        {
                            "answer": "Tail Recursive functions use more memory than iterative constructs",
                            "correct": false
                        },
                        {
                            "answer": "Iterative constructs use more memory than recursion",
                            "correct": false
                        }
                    ],
                    "explanation" : "Recursive functions can be slower and consume more memory than equivalent iterative constructs due to the overhead of function calls.",
                    "finished": false
                },
                {
                    "id": 12,
                    "question": "Which one is not a feature of COMMON LISP?",
                    "answers": [
                        {
                            "answer": "Records",
                            "correct": false
                        },
                        {
                            "answer": "Arrays",
                            "correct": false
                        },
                        {
                            "answer": "Complex numbers",
                            "correct": false
                        },
                        {
                            "answer": "Variables",
                            "correct": true
                        }
                    ],
                    "explanation" : "COMMON LISP does not consider 'variables' as a distinctive feature, as variables are a fundamental concept in most programming languages, including COMMON LISP.",
                    "finished": false
                },
                {
                    "id": 13,
                    "question": "Which one of the following is not a characteristic of functional programming languages?",
                    "answers": [
                        {
                            "answer": "Simple semantics",
                            "correct": false
                        },
                        {
                            "answer": "Simple syntax",
                            "correct": false
                        },
                        {
                            "answer": "Programs can automatically be concurrent",
                            "correct": false
                        },
                        {
                            "answer": "Efficient execution",
                            "correct": true
                        }
                    ],
                    "explanation" : "While functional programming languages offer many benefits, they are not necessarily known for inherently efficient execution. Efficiency depends on various factors, including the language implementation and the specific code.",
                    "finished": false
                },
                {
                    "id": 14,
                    "question": "LISP was first used for Artificial Intelligence.",
                    "answers": [
                        {
                            "answer": "True",
                            "correct": true
                        },
                        {
                            "answer": "False",
                            "correct": false
                        }
                    ],
                    "explanation" : "LISP (List Processing) was one of the earliest programming languages used for Artificial Intelligence research and development.",
                    "finished": false
                }
            ]
        },
        {
            "id": 3,
            "name": "Chapter 4 - Logic Programming Languages",
            "questions": [
                {
                    "id": 0,
                    "question": "Logic programming languages are also referred to as declarative programming languages.",
                    "answers": [
                        {
                            "answer": "True",
                            "correct": true
                        },
                        {
                            "answer": "False",
                            "correct": false
                        }
                    ],
                    "explanation" : "Logic programming languages, like Prolog, are indeed considered declarative because they focus on specifying what should be done rather than how it should be done.",
                    "finished": false
                },
                {
                    "id": 1,
                    "question": "A proposition consists of:",
                    "answers": [
                        {
                            "answer": "One object",
                            "correct": false
                        },
                        {
                            "answer": "Two objects",
                            "correct": false
                        },
                        {
                            "answer": "Three objects",
                            "correct": false
                        },
                        {
                            "answer": "One or more objects",
                            "correct": true
                        }
                    ],
                    "explanation" : "A proposition can involve one or more objects or elements that are used to make statements or assertions.",
                    "finished": false
                },
                {
                    "id": 2,
                    "question": "Logic programming is based on first-order predicate calculus.",
                    "answers": [
                        {
                            "answer": "True",
                            "correct": true
                        },
                        {
                            "answer": "False",
                            "correct": false
                        }
                    ],
                    "explanation" : "Logic programming, such as Prolog, is grounded in first-order predicate calculus, which deals with relationships and logical assertions using predicates and quantifiers.",
                    "finished": false
                },
                {
                    "id": 3,
                    "question": "Which of the following is an atomic proposition?",
                    "answers": [
                        {
                            "answer": "Complex proposition",
                            "correct": false
                        },
                        {
                            "answer": "Atomic proposition",
                            "correct": true
                        },
                        {
                            "answer": "Simple proposition",
                            "correct": false
                        },
                        {
                            "answer": "Mathematical proposition",
                            "correct": false
                        }
                    ],
                    "explanation" : "An atomic proposition is a basic, indivisible statement in logic, which contrasts with complex propositions that are composed of multiple atomic propositions.",
                    "finished": false
                },
                {
                    "id": 4,
                    "question": "Resolution can be used to prove theorems.",
                    "answers": [
                        {
                            "answer": "True",
                            "correct": true
                        },
                        {
                            "answer": "False",
                            "correct": false
                        }
                    ],
                    "explanation" : "Resolution is a logical inference method used in theorem proving and is a fundamental technique in logic-based programming languages like Prolog.",
                    "finished": false
                },
                {
                    "id": 5,
                    "question": "Which of the following is not a basic element that makes up Prolog?",
                    "answers": [
                        {
                            "answer": "Fact Statements",
                            "correct": false
                        },
                        {
                            "answer": "Truth Statements",
                            "correct": true
                        },
                        {
                            "answer": "Goal Statements",
                            "correct": false
                        },
                        {
                            "answer": "Rule Statements",
                            "correct": false
                        }
                    ],
                    "explanation" : "Prolog primarily consists of Fact Statements (facts about the world), Goal Statements (queries or goals to prove), and Rule Statements (rules defining relationships), but 'Truth Statements' are not a recognized component.",
                    "finished": false
                },
                {
                    "id": 6,
                    "question": "A rule statement is used for theorems.",
                    "answers": [
                        {
                            "answer": "True",
                            "correct": true
                        },
                        {
                            "answer": "False",
                            "correct": false
                        }
                    ],
                    "explanation" : "Rule statements in Prolog are used to define relationships and can be utilized in proving theorems or solving problems.",
                    "finished": false
                },
                {
                    "id": 7,
                    "question": "A theorem is a proposition that Prolog does not have to prove.",
                    "answers": [
                        {
                            "answer": "True",
                            "correct": false
                        },
                        {
                            "answer": "False",
                            "correct": true
                        }
                    ],
                    "explanation" : "In Prolog, a theorem is a proposition or statement that you want Prolog to prove or derive based on the given facts and rules.",
                    "finished": false
                },
                {
                    "id": 8,
                    "question": "Prolog has which inferencing process?",
                    "answers": [
                        {
                            "answer": "Bottom-up, left-right",
                            "correct": false
                        },
                        {
                            "answer": "Top-down, left-right",
                            "correct": false
                        },
                        {
                            "answer": "Bottom-up, right-left",
                            "correct": false
                        },
                        {
                            "answer": "Top-down, left-right",
                            "correct": true
                        }
                    ],
                    "explanation" : "Prolog employs a top-down, left-right inference strategy where it starts with the goal and tries to satisfy it by using available facts and rules.",
                    "finished": false
                },
                {
                    "id": 9,
                    "question": "Which one of the following is not an event in the Tracing model?",
                    "answers": [
                        {
                            "answer": "Call",
                            "correct": false
                        },
                        {
                            "answer": "Exit",
                            "correct": false
                        },
                        {
                            "answer": "Retry",
                            "correct": false
                        },
                        {
                            "answer": "Fail",
                            "correct": false
                        }
                    ],
                    "explanation" : "In the Prolog tracing model, events like 'Call', 'Exit', and 'Fail' are tracked, but 'Retry' is not one of the standard events.",
                    "finished": false
                },
                {
                    "id": 10,
                    "question": "Variables on the left hand side of the IS operator must be instantiated.",
                    "answers": [
                        {
                            "answer": "True",
                            "correct": false
                        },
                        {
                            "answer": "False",
                            "correct": true
                        }
                    ],
                    "explanation" : "In Prolog, variables on the left-hand side of the 'is' operator (=) must be instantiated (have a value) for the assignment to occur.",
                    "finished": false
                },
                {
                    "id": 11,
                    "question": "Base case statements must appear first in a recursive proposition.",
                    "answers": [
                        {
                            "answer": "True",
                            "correct": true
                        },
                        {
                            "answer": "False",
                            "correct": false
                        }
                    ],
                    "explanation" : "In recursive propositions in Prolog, it is customary to place the base case statements (termination conditions) first to ensure the recursion eventually terminates.",
                    "finished": false
                },
                {
                    "id": 12,
                    "question": "Which one of the following is not a deficiency of Prolog.",
                    "answers": [
                        {
                            "answer": "Resolution order control",
                            "correct": false
                        },
                        {
                            "answer": "The open-world assumption",
                            "correct": true
                        },
                        {
                            "answer": "The negation problem",
                            "correct": false
                        },
                        {
                            "answer": "Intrinsic limitations",
                            "correct": false
                        }
                    ],
                    "explanation" : "'The open-world assumption' is not considered a deficiency of Prolog; it is a characteristic that allows for the flexibility of adding new knowledge without causing contradictions.",
                    "finished": false
                },
                {
                    "id": 13,
                    "question": "Prolog allows for explicit control of backtracking via cuts.",
                    "answers": [
                        {
                            "answer": "True",
                            "correct": true
                        },
                        {
                            "answer": "False",
                            "correct": false
                        }
                    ],
                    "explanation" : "Prolog provides the 'cut' operator (!) for explicit control over backtracking, allowing programmers to make choices about which solutions to commit to.",
                    "finished": false
                },
                {
                    "id": 14,
                    "question": "Prolog has been used in business applications.",
                    "answers": [
                        {
                            "answer": "True",
                            "correct": false
                        },
                        {
                            "answer": "False",
                            "correct": true
                        }
                    ],
                    "explanation" : "Prolog has been employed in various domains, including business applications, for tasks like rule-based reasoning, expert systems, and knowledge representation.",
                    "finished": false
                }
            ]
        }
    ]
}